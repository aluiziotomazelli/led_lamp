/**
 * @file led_controller.c
 * @brief Manages LED state and renders effects.
 *
 * @details This component acts as the "actuator" or "renderer" for the abstract
 * commands generated by the FSM. It is responsible for all logic directly
 * related to the LEDs, including managing brightness, tracking the current
 * effect, and handling effect parameters.
 *
 * ARCHITECTURE:
 * This controller uses a dual-task, shared-state architecture for efficiency
 * and responsiveness:
 *
 * 1.  `command_handler_task`: This task waits blocked on the command queue
 *     (`q_commands_in`). When a command from the FSM arrives, it wakes up,
 *     acquires a mutex, updates the shared `g_led_state` structure, and then
 *     notifies the renderer task that a change has occurred.
 *
 * 2.  `renderer_task`: This task is responsible for generating the pixel data.
 *     - For DYNAMIC effects, it runs in a continuous loop at a fixed framerate.
 *     - For STATIC effects, it remains blocked until it receives a notification
 *       from the command handler, at which point it renders a single new frame
 *       and goes back to sleep. This is a key optimization to save CPU cycles.
 *
 * 3.  Shared State (`g_led_state`): All state variables (brightness, effect
 *     index, etc.) are stored in a single structure. Access to this structure
 *     from either task is protected by a mutex (`g_led_state_mutex`) to ensure
 *     thread safety.
 *
 * This design decouples the event-driven command handling from the continuous
 * (or on-demand) rendering loop, providing a robust and efficient system.
 */
#include "led_controller.h"
#include "esp_log.h"
#include "esp_timer.h"
#include "fsm.h"
#include "project_config.h"
#include <stdlib.h>
#include <string.h>
#include "freertos/semphr.h"
#include "freertos/task.h"

static const char *TAG = "LED_CTRL";

// --- Shared State & Concurrency Control ---

/**
 * @brief Structure to hold the complete state of the LED system.
 *
 * This structure is shared between the command handler and renderer tasks.
 * Access to this structure must be protected by a mutex.
 */
typedef struct {
    bool is_on;
    uint8_t master_brightness;
    uint8_t current_effect_index;
    uint8_t current_param_index;
    effect_param_t *temp_params; // For cancel functionality
} led_state_t;

static led_state_t g_led_state;
static SemaphoreHandle_t g_led_state_mutex;
static TaskHandle_t g_renderer_task_handle = NULL;

// The pixel buffer that holds the current LED colors, used only by renderer
static rgb_t *pixel_buffer = NULL;

// Handles for FreeRTOS objects
static QueueHandle_t q_commands_in = NULL;
static QueueHandle_t q_strip_out = NULL;

// External variables from led_effects.c
extern effect_t *effects[];
extern const uint8_t effects_count;

// Forward declarations for new task-based functions
static void command_handler_task(void *pv);
static void renderer_task(void *pv);
static void handle_command(const led_command_t *cmd);
static void render_frame(void);

/**
 * @brief Applies the master brightness to a single RGB color.
 */
static inline rgb_t apply_brightness(rgb_t color, uint8_t brightness) {
	rgb_t out;
	out.r = (color.r * brightness) / 255;
	out.g = (color.g * brightness) / 255;
	out.b = (color.b * brightness) / 255;
	return out;
}

/**
 * @brief Saves the current parameters of the active effect into a temporary
 * buffer.
 * @note This function MUST be called with the state mutex held.
 */
static void save_temp_params() {
	effect_t *current_effect = effects[g_led_state.current_effect_index];
	if (g_led_state.temp_params) {
		free(g_led_state.temp_params);
		g_led_state.temp_params = NULL;
	}
	if (current_effect->num_params > 0) {
		g_led_state.temp_params =
			malloc(sizeof(effect_param_t) * current_effect->num_params);
		if (g_led_state.temp_params) {
			memcpy(g_led_state.temp_params, current_effect->params,
				   sizeof(effect_param_t) * current_effect->num_params);
		} else {
			ESP_LOGE(TAG, "Failed to allocate memory for temp params");
		}
	}
}

/**
 * @brief Restores the parameters of the active effect from the temporary
 * buffer.
 * @note This function MUST be called with the state mutex held.
 */
static void restore_temp_params() {
	effect_t *current_effect = effects[g_led_state.current_effect_index];
	if (g_led_state.temp_params && current_effect->num_params > 0) {
		memcpy(current_effect->params, g_led_state.temp_params,
			   sizeof(effect_param_t) * current_effect->num_params);
		free(g_led_state.temp_params);
		g_led_state.temp_params = NULL;
	}
}

/**
 * @brief Handles an incoming command from the FSM.
 *
 * This function modifies the shared `g_led_state` and must be protected
 * by a mutex.
 */
static void handle_command(const led_command_t *cmd) {
	xSemaphoreTake(g_led_state_mutex, portMAX_DELAY);

	switch (cmd->cmd) {
	case LED_CMD_TURN_ON:
	case LED_CMD_TURN_ON_FADE:
		g_led_state.is_on = true;
		ESP_LOGI(TAG, "LEDs ON");
		break;

	case LED_CMD_TURN_OFF:
		g_led_state.is_on = false;
		ESP_LOGI(TAG, "LEDs OFF");
		break;

	case LED_CMD_INC_BRIGHTNESS: {
		int32_t new_brightness = (int32_t)g_led_state.master_brightness + cmd->value;
		if (new_brightness > 255) {
			g_led_state.master_brightness = 255;
		} else if (new_brightness < 0) {
			g_led_state.master_brightness = 0;
		} else {
			g_led_state.master_brightness = (uint8_t)new_brightness;
		}
		ESP_LOGI(TAG, "Brightness: %d", g_led_state.master_brightness);
		break;
	}

	case LED_CMD_INC_EFFECT: {
		int32_t new_index = g_led_state.current_effect_index + cmd->value;
		if (new_index < 0)
			new_index = effects_count - 1;
		if (new_index >= effects_count)
			new_index = 0;
		g_led_state.current_effect_index = new_index;
		g_led_state.current_param_index = 0; // Reset param index
		ESP_LOGI(TAG, "Effect changed to: %s",
				 effects[g_led_state.current_effect_index]->name);
		break;
	}

	case LED_CMD_SET_EFFECT: {
		effect_t *current_effect = effects[g_led_state.current_effect_index];
		ESP_LOGI(TAG, "Effect set to: %s", current_effect->name);
		save_temp_params(); // Save params when entering effect setup
		break;
	}
	case LED_CMD_INC_EFFECT_PARAM: {
		effect_t *current_effect = effects[g_led_state.current_effect_index];
		if (current_effect->num_params > 0) {
			effect_param_t *param =
				&current_effect->params[g_led_state.current_param_index];
			param->value += cmd->value * param->step;
			if (param->value > param->max_value)
				param->value = param->max_value;
			if (param->value < param->min_value)
				param->value = param->min_value;
			ESP_LOGI(TAG, "Param '%s' changed to: %d", param->name, param->value);
		}
		break;
	}
	case LED_CMD_NEXT_EFFECT_PARAM: {
		effect_t *current_effect = effects[g_led_state.current_effect_index];
		if (current_effect->num_params > 0) {
			g_led_state.current_param_index =
				(g_led_state.current_param_index + 1) % current_effect->num_params;
			ESP_LOGI(TAG, "Next param: %s",
					 current_effect->params[g_led_state.current_param_index].name);
		}
		break;
	}

	case LED_CMD_SAVE_CONFIG:
		ESP_LOGI(TAG, "Configuration saved.");
		if (g_led_state.temp_params) {
			free(g_led_state.temp_params);
			g_led_state.temp_params = NULL;
		}
		// Here you would save to NVS
		break;

	case LED_CMD_CANCEL_CONFIG:
		ESP_LOGI(TAG, "Configuration cancelled.");
		restore_temp_params();
		break;

	default:
		// Other commands are ignored by the controller
		break;
	}

	xSemaphoreGive(g_led_state_mutex);
}

static void render_frame() {
    xSemaphoreTake(g_led_state_mutex, portMAX_DELAY);

    if (g_led_state.is_on) {
        effect_t *current_effect = effects[g_led_state.current_effect_index];
        if (current_effect->run) {
            current_effect->run(
                current_effect->params, current_effect->num_params,
                g_led_state.master_brightness, esp_timer_get_time() / 1000,
                pixel_buffer, NUM_LEDS);
        }
        // Apply master brightness
        for (uint16_t i = 0; i < NUM_LEDS; i++) {
            pixel_buffer[i] =
                apply_brightness(pixel_buffer[i], g_led_state.master_brightness);
        }
    } else {
        // If off, just clear the buffer
        memset(pixel_buffer, 0, sizeof(rgb_t) * NUM_LEDS);
    }

    xSemaphoreGive(g_led_state_mutex);

    // Send the final pixel buffer to the output queue
    led_strip_t strip_data = {.pixels = pixel_buffer, .num_pixels = NUM_LEDS};
    xQueueOverwrite(q_strip_out, &strip_data);
}

static void renderer_task(void *pv) {
    TickType_t last_wake_time = xTaskGetTickCount();
    const TickType_t tick_rate = pdMS_TO_TICKS(30); // ~33 FPS

    while (1) {
        render_frame();

        xSemaphoreTake(g_led_state_mutex, portMAX_DELAY);
        effect_t *current_effect = effects[g_led_state.current_effect_index];
        bool is_dynamic = (current_effect->type == EFFECT_TYPE_DYNAMIC) && g_led_state.is_on;
        xSemaphoreGive(g_led_state_mutex);

        if (is_dynamic) {
            vTaskDelayUntil(&last_wake_time, tick_rate);
        } else {
            // Wait indefinitely for a notification from the command handler
            ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
            last_wake_time = xTaskGetTickCount(); // Reset tick count on wake
        }
    }
}

static void command_handler_task(void *pv) {
    led_command_t cmd;
    while (1) {
        // Wait indefinitely for a command
        if (xQueueReceive(q_commands_in, &cmd, portMAX_DELAY) == pdTRUE) {
            handle_command(&cmd);
            // Notify the renderer that state has changed
            xTaskNotifyGive(g_renderer_task_handle);
        }
    }
}

QueueHandle_t led_controller_init(QueueHandle_t cmd_queue) {
    if (!cmd_queue) {
        ESP_LOGE(TAG, "Command queue is NULL");
        return NULL;
    }
    q_commands_in = cmd_queue;

    pixel_buffer = malloc(sizeof(rgb_t) * NUM_LEDS);
    if (!pixel_buffer) {
        ESP_LOGE(TAG, "Failed to allocate pixel buffer");
        return NULL;
    }

    q_strip_out = xQueueCreate(1, sizeof(led_strip_t));
    if (!q_strip_out) {
        ESP_LOGE(TAG, "Failed to create output queue");
        free(pixel_buffer);
        return NULL;
    }

    g_led_state_mutex = xSemaphoreCreateMutex();
    if (!g_led_state_mutex) {
        ESP_LOGE(TAG, "Failed to create mutex");
        free(pixel_buffer);
        vQueueDelete(q_strip_out);
        return NULL;
    }

    // Initialize state
    g_led_state.is_on = false;
    g_led_state.master_brightness = 100;
    g_led_state.current_effect_index = 0;
    g_led_state.current_param_index = 0;
    g_led_state.temp_params = NULL;

    BaseType_t result;
    result = xTaskCreate(renderer_task, "LED_Render_T", LED_RENDER_STACK_SIZE, NULL,
                         LED_RENDER_TASK_PRIORITY, &g_renderer_task_handle);
    if (result != pdPASS) {
        ESP_LOGE(TAG, "Failed to create LED renderer task");
        vSemaphoreDelete(g_led_state_mutex);
        free(pixel_buffer);
        vQueueDelete(q_strip_out);
        return NULL;
    }

    result = xTaskCreate(command_handler_task, "LED_Cmd_T", LED_CMD_STACK_SIZE,
                         NULL, LED_CMD_TASK_PRIORITY, NULL);
    if (result != pdPASS) {
        ESP_LOGE(TAG, "Failed to create LED command task");
        vTaskDelete(g_renderer_task_handle);
        vSemaphoreDelete(g_led_state_mutex);
        free(pixel_buffer);
        vQueueDelete(q_strip_out);
        return NULL;
    }

    ESP_LOGI(TAG, "LED Controller initialized with dual-task architecture");
    return q_strip_out;
}